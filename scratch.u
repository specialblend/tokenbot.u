-- sugar
opt ~ x = Optional.getOrElse x opt -- because `?` is reserved :'(
a ->> b = b a -- because `|>` is ugly and `->` is reserved :'(

push = a -> b -> a List.++ b
forceNat = i -> i ->> fromInt ~ 0

-- contract
structural type Item = {
    token: Text,
    qty: Nat,
}

structural type Fx
    = Curse Int 
    | Greed Int 
    | Luck Int 
    | Wealth Int

structural type CakeDay = {
    cake_month: Nat,
    cake_day: Nat,
}

structural type Profile = {
    id: Text,
    name: Text,
    tz_offset: Optional Int,
    cake_day: Optional CakeDay,
}

structural type Player = {
    profile: Profile,
    items: [Item],
    stats: Stats,
    scores: Scores,
}

structural type MicroTxn
    = Give Player Text Int Text
    | Steal Player [Text] Int Text

structural type TxnHeader = {
    timestamp: LocalDateTime,
    sender: Player,
    recipients: [Player]
} 

unique type Scores = {
    base: Nat,
    bonus: Nat,
    penalty: Nat,
    total: Nat,
}

unique type Stats = {
    curse: Nat,
    greed: Nat,
    luck: Nat,
    wealth: Nat,
}

-- player
pOffset = player -> player ->> profile ->> tz_offset ~ +0
pTime = txn -> player -> addDuration (txn ->> timestamp) (player ->> pOffset ->> seconds)

-- txn
players = txn -> (txn ->> sender) +: (txn ->> recipients)

-- tokens
tokens.points = cases
    "👍" -> +1
    "☕" -> +1
    "🍻" -> +2
    "🍕" -> +3
    "🔥" -> +5
    "🍉" -> +8
    "🍰" -> +13
    "👑" -> +1
    "🍀" -> +1
    "🎭" -> +0
    "💀" -> -1
    "🎃" -> +1
    "🎄" -> +1
    _ -> +0

tokens.fx = cases
    "👑" -> [Wealth +25]
    "🍀" -> [Luck +25]
    "🎭" -> [Greed +25]
    "💀" -> [Curse +25]
    "❤️" -> [Curse -50]
    "🎃" -> [Curse +5, Greed +5]
    "🎄" -> [Greed -25]
    _ -> []

-- calculator
init_scores = Scores 0 0 0 0
init_stats = Stats 0 0 0 0

calc.points = 
    use List
    value = item -> tokens.points (item ->> token) * (item ->> qty ->> toInt)
    stack = total -> item -> total + (item ->> value)
    items -> forceNat (foldLeft stack +0 [])

stackStat = qty -> amt -> stat -> forceNat (toInt stat + amt * toInt qty)

stackFx = qty -> stats -> fx -> let
    stack = stackStat qty
    match fx with
    Curse amt -> stats ->> curse.modify (stack amt)
    Greed amt -> stats ->> greed.modify (stack amt)
    Luck amt -> stats ->> luck.modify (stack amt)
    Wealth amt -> stats ->> wealth.modify (stack amt)

calc.stats = let
    use List
    stackItem = stats -> item -> let 
        stack = stackFx (item ->> qty)
        fx = tokens.fx (item ->> token)
        foldLeft stack init_stats fx
    items -> foldLeft stackItem init_stats items

-- date rules
use LocalDateTime

isFriday = now -> (now ->> date ->> day) == 5

isBetweenHours = start -> end -> now -> let
    (now ->> time ->> hour >= start) && (now ->> time ->> hour < end)

-- txn rules
baseTokens = txn -> push (
    txn ->> recipients ->> map (player -> Give player "👍" +1 "thanks")
    )

morningBonus = txn -> push (
    txn ->> players
        ->> filter (player -> player ->> pTime txn ->> isBetweenHours 0 9)
        ->> map (player -> Give player "☕" +1 "morning bonus")
    )

fridayBonus = txn -> push (
    txn ->> players
        ->> filter (player -> player ->> pTime txn ->> isFriday)
        ->> map (player -> Give player "🍻" +1 "friday bonus")
    )

rules = [
    baseTokens,
    morningBonus,
    fridayBonus,
]