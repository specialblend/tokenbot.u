-- sugar
opt ~ x = Optional.getOrElse x opt
a ->> b = b a -- preference over |>

push a b = a List.++ b
forceNat i = fromInt i ~ 0

-- contract
structural type Item = {
    token: Text,
    qty: Nat,
}

structural type Fx
    = Curse Int 
    | Greed Int 
    | Luck Int 
    | Wealth Int

structural type CakeDay = {
    cake_month: Nat,
    cake_day: Nat,
}

structural type Profile = {
    id: Text,
    name: Text,
    tz_offset: Optional Int,
    cake_day: Optional CakeDay,
}

structural type Player = {
    profile: Profile,
    items: [Item],
    stats: Stats,
    scores: Scores,
}

structural type MicroTxn
    = Give Player Text Int Text
    | Steal Player [Text] Int Text

structural type TxnHeader = {
    timestamp: LocalDateTime,
    sender: Player,
    recipients: [Player]
} 

unique type Scores = {
    base: Nat,
    bonus: Nat,
    penalty: Nat,
    total: Nat,
}

unique type Stats = {
    curse: Nat,
    greed: Nat,
    luck: Nat,
    wealth: Nat,
}

-- player
pOffset player = player ->> profile ->> tz_offset ~ +0
pTime txn player = addDuration (txn ->> timestamp) (player ->> pOffset ->> seconds)

-- txn
players txn = txn ->> sender +: (txn ->> recipients)

-- tokens
tokens.points = cases
    "ğŸ‘" -> +1
    "â˜•" -> +1
    "ğŸ»" -> +2
    "ğŸ•" -> +3
    "ğŸ”¥" -> +5
    "ğŸ‰" -> +8
    "ğŸ°" -> +13
    "ğŸ‘‘" -> +1
    "ğŸ€" -> +1
    "ğŸ­" -> +0
    "ğŸ’€" -> -1
    "ğŸƒ" -> +1
    "ğŸ„" -> +1
    _ -> +0

tokens.fx = cases
    "ğŸ‘‘" -> [Wealth +25]
    "ğŸ€" -> [Luck +25]
    "ğŸ­" -> [Greed +25]
    "ğŸ’€" -> [Curse +25]
    "â¤ï¸" -> [Curse -50]
    "ğŸƒ" -> [Curse +5, Greed +5]
    "ğŸ„" -> [Greed -25]
    _ -> []

-- calculator
init_scores = Scores 0 0 0 0
init_stats = Stats 0 0 0 0

calc.points items = 
    use List
    value item = tokens.points (item ->> token) * (item ->> qty ->> toInt)
    stack total item = total + (item ->> value)
    forceNat (foldLeft stack +0 items)

stackStat qty amt stat = forceNat (toInt stat + amt * toInt qty)

stackFx qty stats fx =
    stack = stackStat qty
    match fx with
    Curse amt -> stats ->> curse.modify (stack amt)
    Greed amt -> stats ->> greed.modify (stack amt)
    Luck amt -> stats ->> luck.modify (stack amt)
    Wealth amt -> stats ->> wealth.modify (stack amt)

calc.stats items = 
    use List
    stackItem stats item =
        stack = stackFx (item ->> qty)
        fx = tokens.fx (item ->> token)
        foldLeft stack init_stats fx
    foldLeft stackItem init_stats items

-- collector
-- collectTokens rules txn =

-- date rules
use LocalDateTime

isFriday now = (now ->> date ->> day) == 5

isBetweenHours start end now =
    h = now ->> time ->> hour
    (h >= start) && (h < end)

-- txn rules
baseTokens txn = push (
    txn ->> recipients ->> map (player -> Give player "ğŸ‘" +1 "thanks")
    )

morningBonus txn = push (
    txn ->> players
        ->> filter (player -> player ->> pTime txn ->> isBetweenHours 0 9)
        ->> map (player -> Give player "â˜•" +1 "morning bonus")
    )

fridayBonus txn = push (
    txn ->> players
        ->> filter (player -> player ->> pTime txn ->> isFriday)
        ->> map (player -> Give player "ğŸ»" +1 "friday bonus")
    )

rules = [
    baseTokens,
    morningBonus,
    fridayBonus,
]

-- tests
test> forceNat.tests._3when3 = check (forceNat +3 == 3)
test> forceNat.tests._1when1 = check (forceNat +1 == 1)
test> forceNat.tests._0when0 = check (forceNat +0 == 0)
test> forceNat.tests._0when_1 = check (forceNat -1 == 0)
test> forceNat.tests._0when_3 = check (forceNat -3 == 0)

test> calc.points.tests._0whenEmpty = check (calc.points [] == 0)
test> calc.points.tests._0whenUnknown = check (calc.points [Item "ğŸˆ" 1] == 0)
test> calc.points.tests._1when1Like = check (calc.points [Item "ğŸ‘" 1] == 1)
test> calc.points.tests._3when3Likes = check (calc.points [Item "ğŸ‘" 3] == 3)
test> calc.points.tests.mixed2 = check (calc.points [Item "ğŸ‘" 1, Item "ğŸ•" 2] == 7)
test> calc.points.tests.mixed3 = check (calc.points [Item "ğŸ‘" 1, Item "ğŸ•" 2, Item "ğŸ’€" 3] == 4)

test> calc.stats.tests.initCurseWhenEmpty = check ((calc.stats []) ->> curse == (init_stats ->> curse))
test> calc.stats.tests.initGreedWhenEmpty = check ((calc.stats []) ->> greed == (init_stats ->> greed))
test> calc.stats.tests.initLuckWhenEmpty = check ((calc.stats []) ->> luck == (init_stats ->> luck))
test> calc.stats.tests.initWealthWhenEmpty = check ((calc.stats []) ->> wealth == (init_stats ->> wealth))
