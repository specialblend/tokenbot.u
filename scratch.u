-- sugar
opt ~ x = Optional.getOrElse x opt -- because `?` is reserved :'(
a ->> b = b a -- because `|>` is ugly and `->` is reserved :'(

push = a -> b -> a List.++ b
forceNat = i -> i ->> fromInt ~ 0

-- contract
structural type Item = {
    token: Text,
    qty: Nat,
}

structural type Fx
    = Curse Int 
    | Greed Int 
    | Luck Int 
    | Wealth Int

structural type CakeDay = {
    cake_month: Nat,
    cake_day: Nat,
}

structural type Profile = {
    id: Text,
    name: Text,
    tz_offset: Optional Int,
    cake_day: Optional CakeDay,
}

structural type Player = {
    profile: Profile,
    items: [Item],
    stats: Stats,
    scores: Scores,
}

structural type MicroTxn
    = Give Player Text Int Text
    | Steal Player [Text] Int Text

structural type TxnHeader = {
    timestamp: LocalDateTime,
    sender: Player,
    recipients: [Player]
} 

unique type Scores = {
    base: Nat,
    bonus: Nat,
    penalty: Nat,
    total: Nat,
}

unique type Stats = {
    curse: Nat,
    greed: Nat,
    luck: Nat,
    wealth: Nat,
}

-- player
pOffset = player -> player ->> profile ->> tz_offset ~ +0
pTime = txn -> player -> addDuration (txn ->> timestamp) (player ->> pOffset ->> seconds)

-- txn
players = txn -> (txn ->> sender) +: (txn ->> recipients)

-- tokens
tokens.points = cases
    "ğŸ‘" -> +1
    "â˜•" -> +1
    "ğŸ»" -> +2
    "ğŸ•" -> +3
    "ğŸ”¥" -> +5
    "ğŸ‰" -> +8
    "ğŸ°" -> +13
    "ğŸ‘‘" -> +1
    "ğŸ€" -> +1
    "ğŸ­" -> +0
    "ğŸ’€" -> -1
    "ğŸƒ" -> +1
    "ğŸ„" -> +1
    _ -> +0

tokens.fx = cases
    "ğŸ‘‘" -> [Wealth +25]
    "ğŸ€" -> [Luck +25]
    "ğŸ­" -> [Greed +25]
    "ğŸ’€" -> [Curse +25]
    "â¤ï¸" -> [Curse -50]
    "ğŸƒ" -> [Curse +5, Greed +5]
    "ğŸ„" -> [Greed -25]
    _ -> []

-- calculator
init_scores = Scores 0 0 0 0
init_stats = Stats 0 0 0 0

calc.points = 
    use List
    value = item -> tokens.points (item ->> token) * (item ->> qty ->> toInt)
    stack = total -> item -> total + (item ->> value)
    items -> forceNat (foldLeft stack +0 [])

stackStat = qty -> amt -> stat -> forceNat (toInt stat + amt * toInt qty)

stackFx = qty -> stats -> fx -> let
    stack = stackStat qty
    match fx with
    Curse amt -> stats ->> curse.modify (stack amt)
    Greed amt -> stats ->> greed.modify (stack amt)
    Luck amt -> stats ->> luck.modify (stack amt)
    Wealth amt -> stats ->> wealth.modify (stack amt)

calc.stats = let
    use List
    stackItem = stats -> item -> let 
        stack = stackFx (item ->> qty)
        fx = tokens.fx (item ->> token)
        foldLeft stack init_stats fx
    items -> foldLeft stackItem init_stats items

-- date rules
use LocalDateTime

isFriday = now -> (now ->> date ->> day) == 5

isBetweenHours = start -> end -> now -> let
    (now ->> time ->> hour >= start) && (now ->> time ->> hour < end)

-- txn rules
baseTokens = txn -> push (
    txn ->> recipients ->> map (player -> Give player "ğŸ‘" +1 "thanks")
    )

morningBonus = txn -> push (
    txn ->> players
        ->> filter (player -> player ->> pTime txn ->> isBetweenHours 0 9)
        ->> map (player -> Give player "â˜•" +1 "morning bonus")
    )

fridayBonus = txn -> push (
    txn ->> players
        ->> filter (player -> player ->> pTime txn ->> isFriday)
        ->> map (player -> Give player "ğŸ»" +1 "friday bonus")
    )

rules = [
    baseTokens,
    morningBonus,
    fridayBonus,
]